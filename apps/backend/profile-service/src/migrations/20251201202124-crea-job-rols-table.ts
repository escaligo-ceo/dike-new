import {
  MigrationInterface,
  QueryRunner,
  Table,
  TableColumn,
  TableForeignKey,
} from "typeorm";

export class CreaJobRolsTable20251201202124 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    // Create job_roles table (guard if already exists)
    const hasJobRoles = await queryRunner.hasTable("job_roles");
    if (!hasJobRoles) {
      await queryRunner.createTable(
        new Table({
          name: "job_roles",
          columns: [
            {
              name: "id",
              type: "int",
              isPrimary: true,
              isGenerated: true,
              generationStrategy: "increment",
            },
            {
              name: "tenant_id",
              type: "int",
              isNullable: true,
            },
            {
              name: "name",
              type: "varchar",
              length: "100",
            },
            {
              name: "is_custom",
              type: "boolean",
              default: false,
            },
            {
              name: "is_default",
              type: "boolean",
              default: false,
            },
            {
              name: "created_at",
              type: "timestamp",
              default: "CURRENT_TIMESTAMP",
            },
            {
              name: "updated_at",
              type: "timestamp",
              default: "CURRENT_TIMESTAMP",
              onUpdate: "CURRENT_TIMESTAMP",
            },
          ],
        }),
        true
      );
    }

    // Add foreign key to tenants (optional)
    if (
      (await queryRunner.hasTable("job_roles")) &&
      (await queryRunner.hasTable("tenants"))
    ) {
      const jobRolesTable = await queryRunner.getTable("job_roles");
      const tenantFK = jobRolesTable?.foreignKeys.find((fk) =>
        fk.columnNames.includes("tenant_id")
      );
      if (!tenantFK) {
        await queryRunner.createForeignKey(
          "job_roles",
          new TableForeignKey({
            columnNames: ["tenant_id"],
            referencedTableName: "tenants",
            referencedColumnNames: ["id"],
            onDelete: "CASCADE",
          })
        );
      }
    }

    // Add job_role_id to profiles
    await queryRunner.addColumn(
      "profiles",
      new TableColumn({
        name: "job_role_id",
        type: "int",
        isNullable: true,
      })
    );

    // FK profiles.job_role_id -> job_roles.id (create only if not exists)
    const profilesTable = await queryRunner.getTable("profiles");
    const existingFK = profilesTable?.foreignKeys.find(
      (fk) =>
        fk.columnNames.includes("job_role_id") &&
        fk.referencedTableName === "job_roles"
    );
    if (!existingFK) {
      await queryRunner.createForeignKey(
        "profiles",
        new TableForeignKey({
          columnNames: ["job_role_id"],
          referencedTableName: "job_roles",
          referencedColumnNames: ["id"],
          onDelete: "SET NULL",
        })
      );
    }

    // Ensure required columns exist on job_roles (for previously broken runs)
    const jobRoles = await queryRunner.getTable("job_roles");
    const hasName = jobRoles?.findColumnByName("name");
    if (!hasName) {
      // Add as nullable first to avoid rewrite errors, then backfill and set NOT NULL
      await queryRunner.addColumn(
        "job_roles",
        new TableColumn({
          name: "name",
          type: "varchar",
          length: "100",
          isNullable: true,
        })
      );
      // Backfill existing rows with a placeholder
      await queryRunner.query(
        `UPDATE job_roles SET name = 'Senza nome' WHERE name IS NULL;`
      );
      // Alter to NOT NULL
      await queryRunner.query(
        `ALTER TABLE job_roles ALTER COLUMN name SET NOT NULL;`
      );
    }
    const hasIsCustom = jobRoles?.findColumnByName("is_custom");
    if (!hasIsCustom) {
      await queryRunner.addColumn(
        "job_roles",
        new TableColumn({
          name: "is_custom",
          type: "boolean",
          default: false as any,
        })
      );
    }
    const hasIsDefault = jobRoles?.findColumnByName("is_default");
    if (!hasIsDefault) {
      await queryRunner.addColumn(
        "job_roles",
        new TableColumn({
          name: "is_default",
          type: "boolean",
          default: false as any,
        })
      );
    }

    // Ensure id is auto-generated when table pre-existed without default/sequence
    const idColumn = jobRoles?.findColumnByName("id");
    if (idColumn && !idColumn.isGenerated) {
      // Prefer identity; if not supported, fallback to sequence
      try {
        await queryRunner.query(
          `ALTER TABLE job_roles ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY`
        );
      } catch (e) {
        // Fallback: create sequence and set default
        await queryRunner.query(
          `DO $$
          BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_class WHERE relname = 'job_roles_id_seq') THEN
              CREATE SEQUENCE job_roles_id_seq;
            END IF;
          END$$;`
        );
        await queryRunner.query(
          `ALTER TABLE job_roles ALTER COLUMN id SET DEFAULT nextval('job_roles_id_seq');`
        );
        await queryRunner.query(
          `ALTER SEQUENCE job_roles_id_seq OWNED BY job_roles.id;`
        );
      }
      // Advance identity/sequence to max(id)+1 to avoid PK conflicts
      await queryRunner.query(
        `SELECT setval(
           COALESCE(
             (SELECT pg_get_serial_sequence('job_roles','id')),
             'job_roles_id_seq'
           ),
           COALESCE((SELECT MAX(id) FROM job_roles), 0) + 1,
           false
         );`
      );
    }

    // Insert default roles if not present; if legacy 'label' column exists, populate it from name
    const hasLabel = jobRoles?.findColumnByName("label");
    if (hasLabel) {
      // Backfill any existing null labels from name
      await queryRunner.query(
        `UPDATE job_roles SET label = name WHERE label IS NULL AND name IS NOT NULL;`
      );
      await queryRunner.query(`
            INSERT INTO job_roles (label, name, is_custom, is_default)
            SELECT v.name, v.name, v.is_custom, v.is_default
            FROM (VALUES
              ('Avvocato', false, true),
              ('Praticante', false, false),
              ('Collaboratore', false, false),
              ('Segretaria', false, false)
            ) AS v(name, is_custom, is_default)
            WHERE NOT EXISTS (
              SELECT 1 FROM job_roles jr WHERE jr.name = v.name
            );
          `);
    } else {
      await queryRunner.query(`
            INSERT INTO job_roles (name, is_custom, is_default)
            SELECT v.name, v.is_custom, v.is_default
            FROM (VALUES
              ('Avvocato', false, true),
              ('Praticante', false, false),
              ('Collaboratore', false, false),
              ('Segretaria', false, false)
            ) AS v(name, is_custom, is_default)
            WHERE NOT EXISTS (
              SELECT 1 FROM job_roles jr WHERE jr.name = v.name
            );
          `);
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // Drop FK from profiles
    const profileTable = await queryRunner.getTable("profiles");
    const profileFK = profileTable!.foreignKeys.find((fk) =>
      fk.columnNames.includes("job_role_id")
    );
    if (profileFK) {
      await queryRunner.dropForeignKey("profiles", profileFK);
    }
    await queryRunner.dropColumn("profiles", "job_role_id");

    // Drop FK from job_roles
    const jobRolesTable = await queryRunner.getTable("job_roles");
    const tenantFK = jobRolesTable!.foreignKeys.find((fk) =>
      fk.columnNames.includes("tenant_id")
    );
    if (tenantFK) {
      await queryRunner.dropForeignKey("job_roles", tenantFK);
    }

    // Drop job_roles table
    await queryRunner.dropTable("job_roles");
  }
}
